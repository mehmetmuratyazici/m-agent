import * as vscode from 'vscode';
import { askAI, clearConversationHistory, getConversationHistory, restoreConversationHistory, ChatMessage, setAIProvider, getCurrentProvider, getProviderDisplayName, getAvailableProviders, checkProviderAvailability, AIProvider } from './AIProviderManager';
import { marked } from 'marked';
import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import { initializeProviderManager } from './AIProviderManager';

// Dosya i≈ülemleri i√ßin yardƒ±mcƒ± fonksiyonlar
async function getProjectFiles(): Promise<string[]> {
  const workspaceFolders = vscode.workspace.workspaceFolders;
  if (!workspaceFolders) return [];

  const files: string[] = [];
  
  for (const folder of workspaceFolders) {
    const pattern = new vscode.RelativePattern(folder, '**/*');
    const fileUris = await vscode.workspace.findFiles(pattern, '**/node_modules/**');
    
    for (const uri of fileUris) {
      files.push(uri.fsPath);
    }
  }
  
  return files;
}

async function readFileContent(filePath: string): Promise<string> {
  try {
    const content = await fs.promises.readFile(filePath, 'utf8');
    return content;
  } catch (error) {
    throw new Error(`Dosya okunamadƒ±: ${filePath}`);
  }
}

async function writeFileContent(filePath: string, content: string): Promise<void> {
  try {
    // Dizin yoksa olu≈ütur
    const dir = path.dirname(filePath);
    if (!fs.existsSync(dir)) {
      await fs.promises.mkdir(dir, { recursive: true });
    }
    
    await fs.promises.writeFile(filePath, content, 'utf8');
  } catch (error) {
    throw new Error(`Dosya yazƒ±lamadƒ±: ${filePath}`);
  }
}

async function getFileTree(): Promise<string> {
  const workspaceFolders = vscode.workspace.workspaceFolders;
  if (!workspaceFolders) return '';

  let tree = '';
  
  for (const folder of workspaceFolders) {
    tree += `üìÅ ${folder.name}\n`;
    tree += await buildFileTree(folder.uri.fsPath, '  ');
  }
  
  return tree;
}

async function buildFileTree(dirPath: string, indent: string): Promise<string> {
  let tree = '';
  
  try {
    const items = await fs.promises.readdir(dirPath);
    
    for (const item of items) {
      if (item === 'node_modules' || item === '.git' || item === 'dist') continue;
      
      const fullPath = path.join(dirPath, item);
      const stat = await fs.promises.stat(fullPath);
      
      if (stat.isDirectory()) {
        tree += `${indent}üìÅ ${item}\n`;
        tree += await buildFileTree(fullPath, indent + '  ');
      } else {
        tree += `${indent}üìÑ ${item}\n`;
      }
    }
  } catch (error) {
    // Hata durumunda sessizce devam et
  }
  
  return tree;
}

// Resim i≈üleme fonksiyonlarƒ±
async function saveImageToProject(imageData: string, context: vscode.ExtensionContext): Promise<string> {
  try {
    // Base64'ten binary'e √ßevir
    const base64Data = imageData.replace(/^data:image\/[a-z]+;base64,/, '');
    const imageBuffer = Buffer.from(base64Data, 'base64');
    
    // Resim formatƒ±nƒ± belirle
    const format = imageData.match(/data:image\/([a-z]+);base64/)?.[1] || 'png';
    const extension = format === 'jpeg' ? 'jpg' : format;
    
    // Benzersiz dosya adƒ± olu≈ütur
    const timestamp = Date.now();
    const randomId = crypto.randomBytes(8).toString('hex');
    const fileName = `uploaded_image_${timestamp}_${randomId}.${extension}`;
    
    // Proje i√ßinde images klas√∂r√º olu≈ütur
    const workspaceFolders = vscode.workspace.workspaceFolders;
    let imagesDir: string;
    
    if (workspaceFolders && workspaceFolders.length > 0) {
      imagesDir = path.join(workspaceFolders[0].uri.fsPath, 'images');
    } else {
      // Workspace yoksa extension storage'da sakla
      imagesDir = path.join(context.globalStorageUri.fsPath, 'images');
    }
    
    // Dizin yoksa olu≈ütur
    if (!fs.existsSync(imagesDir)) {
      await fs.promises.mkdir(imagesDir, { recursive: true });
    }
    
    const imagePath = path.join(imagesDir, fileName);
    await fs.promises.writeFile(imagePath, imageBuffer);
    
    return imagePath;
  } catch (error) {
    throw new Error(`Resim kaydedilemedi: ${error}`);
  }
}

async function encodeImageToBase64(imagePath: string): Promise<string> {
  try {
    const imageBuffer = await fs.promises.readFile(imagePath);
    const base64 = imageBuffer.toString('base64');
    
    // Resim formatƒ±nƒ± belirle
    const ext = path.extname(imagePath).toLowerCase();
    let mimeType = 'image/png';
    
    if (ext === '.jpg' || ext === '.jpeg') mimeType = 'image/jpeg';
    else if (ext === '.gif') mimeType = 'image/gif';
    else if (ext === '.webp') mimeType = 'image/webp';
    
    return `data:${mimeType};base64,${base64}`;
  } catch (error) {
    throw new Error(`Resim encode edilemedi: ${error}`);
  }
}

// Conversation history'yi kaydetme ve y√ºkleme fonksiyonlarƒ±
function getHistoryFilePath(context: vscode.ExtensionContext): string {
  return path.join(context.globalStorageUri.fsPath, 'conversation-history.json');
}

async function saveConversationHistory(context: vscode.ExtensionContext): Promise<void> {
  try {
    const history = getConversationHistory();
    const historyPath = getHistoryFilePath(context);
    
    // Dizin yoksa olu≈ütur
    const dir = path.dirname(historyPath);
    if (!fs.existsSync(dir)) {
      await fs.promises.mkdir(dir, { recursive: true });
    }
    
    await fs.promises.writeFile(historyPath, JSON.stringify(history, null, 2), 'utf8');
  } catch (error) {
    console.error('Conversation history kaydedilemedi:', error);
  }
}

async function loadConversationHistory(context: vscode.ExtensionContext): Promise<ChatMessage[]> {
  try {
    const historyPath = getHistoryFilePath(context);
    
    if (fs.existsSync(historyPath)) {
      const data = await fs.promises.readFile(historyPath, 'utf8');
      const history = JSON.parse(data) as ChatMessage[];
      
      // History'yi GeminiAIClient'a y√ºkle
      await restoreConversationHistory(history);
      
      return history;
    }
  } catch (error) {
    console.error('Conversation history y√ºklenemedi:', error);
  }
  
  return [];
}

// AI yanƒ±tƒ±nƒ± analiz edip dosya i≈ülemlerini ger√ßekle≈ütir
async function processAIResponse(response: string, webviewView: vscode.WebviewView): Promise<string> {
  let processedResponse = response;
  
  try {
    // Workspace root'unu al
    const workspaceFolders = vscode.workspace.workspaceFolders;
    let workspaceRoot: string;
    
    if (!workspaceFolders || workspaceFolders.length === 0) {
      // Workspace yoksa, kullanƒ±cƒ±nƒ±n home dizininde yeni bir proje klas√∂r√º olu≈ütur
      const homeDir = process.env.HOME || process.env.USERPROFILE || '';
      if (!homeDir) {
        throw new Error('Home dizini bulunamadƒ±');
      }
      
      // Yeni proje klas√∂r√º olu≈ütur
      const projectName = 'ai-generated-project';
      workspaceRoot = path.join(homeDir, projectName);
      
      // Klas√∂r yoksa olu≈ütur
      if (!fs.existsSync(workspaceRoot)) {
        await fs.promises.mkdir(workspaceRoot, { recursive: true });
      }
      
      // VSCode'da yeni workspace a√ß
      const workspaceUri = vscode.Uri.file(workspaceRoot);
      await vscode.commands.executeCommand('vscode.openFolder', workspaceUri);
      
      processedResponse += `\n\nüìÅ **Yeni proje klas√∂r√º olu≈üturuldu:** \`${workspaceRoot}\``;
    } else {
      workspaceRoot = workspaceFolders[0].uri.fsPath;
    }
    
    // Dosya olu≈üturma komutlarƒ±nƒ± ara (daha spesifik pattern)
    const fileCreatePattern = /```(?:file|create|new):([^\n]+)\n([\s\S]*?)```/g;
    let fileCreateMatch;
    
    while ((fileCreateMatch = fileCreatePattern.exec(response)) !== null) {
      const relativePath = fileCreateMatch[1].trim();
      const fileContent = fileCreateMatch[2].trim();
      
      // G√∂receli yolu tam yola √ßevir
      const fullPath = path.isAbsolute(relativePath) 
        ? relativePath 
        : path.join(workspaceRoot, relativePath);
      
      try {
        // Dosyayƒ± olu≈ütur
        await writeFileContent(fullPath, fileContent);
        
        // Ba≈üarƒ± mesajƒ±nƒ± ekle
        processedResponse += `\n\n‚úÖ **Dosya olu≈üturuldu:** \`${relativePath}\``;
        
        // Webview'a bildirim g√∂nder
        webviewView.webview.postMessage({ 
          command: 'fileWritten', 
          filePath: relativePath 
        });
      } catch (error) {
        processedResponse += `\n\n‚ùå **Dosya olu≈üturulamadƒ±:** \`${relativePath}\` - ${error}`;
      }
    }
    
    // Dosya g√ºncelleme komutlarƒ±nƒ± ara
    const fileUpdatePattern = /```(?:update|edit):([^\n]+)\n([\s\S]*?)```/g;
    let fileUpdateMatch;
    
    while ((fileUpdateMatch = fileUpdatePattern.exec(response)) !== null) {
      const relativePath = fileUpdateMatch[1].trim();
      const fileContent = fileUpdateMatch[2].trim();
      
      // G√∂receli yolu tam yola √ßevir
      const fullPath = path.isAbsolute(relativePath) 
        ? relativePath 
        : path.join(workspaceRoot, relativePath);
      
      try {
        // Dosyayƒ± g√ºncelle
        await writeFileContent(fullPath, fileContent);
        
        // Ba≈üarƒ± mesajƒ±nƒ± ekle
        processedResponse += `\n\n‚úÖ **Dosya g√ºncellendi:** \`${relativePath}\``;
        
        // Webview'a bildirim g√∂nder
        webviewView.webview.postMessage({ 
          command: 'fileWritten', 
          filePath: relativePath 
        });
      } catch (error) {
        processedResponse += `\n\n‚ùå **Dosya g√ºncellenemedi:** \`${relativePath}\` - ${error}`;
      }
    }
    
    // Dosya okuma komutlarƒ±nƒ± ara
    const fileReadPattern = /```(?:read|show):([^\n]+)```/g;
    let fileReadMatch;
    
    while ((fileReadMatch = fileReadPattern.exec(response)) !== null) {
      const relativePath = fileReadMatch[1].trim();
      
      // G√∂receli yolu tam yola √ßevir
      const fullPath = path.isAbsolute(relativePath) 
        ? relativePath 
        : path.join(workspaceRoot, relativePath);
      
      try {
        // Dosyayƒ± oku
        const content = await readFileContent(fullPath);
        
        // Dosya i√ßeriƒüini AI yanƒ±tƒ±na ekle
        processedResponse += `\n\nüìÑ **Dosya i√ßeriƒüi:** \`${relativePath}\`\n\`\`\`\n${content}\n\`\`\``;
        
        // Dosya i√ßeriƒüini webview'a da g√∂nder
        webviewView.webview.postMessage({ 
          command: 'fileContent', 
          filePath: relativePath, 
          content: content 
        });
      } catch (error) {
        processedResponse += `\n\n‚ùå **Dosya okunamadƒ±:** \`${relativePath}\` - ${error}`;
      }
    }
    
  } catch (error) {
    console.error('AI yanƒ±tƒ± i≈ülenirken hata:', error);
  }
  
  return processedResponse;
}

export function activate(context: vscode.ExtensionContext) {
  initializeProviderManager(context); // AIProviderManager'ƒ± ba≈ülat
  context.subscriptions.push(
    vscode.window.registerWebviewViewProvider(
      'aiSidebarView',
      new AIWebviewProvider(context)
    )
  );
}

class AIWebviewProvider implements vscode.WebviewViewProvider {
  private context: vscode.ExtensionContext;
  private historyLoaded = false;

  constructor(context: vscode.ExtensionContext) {
    this.context = context;
    console.log('AIWebviewProvider initialized');
    
    // Extension ba≈üladƒ±ƒüƒ±nda history'yi y√ºkle
    this.loadHistoryOnStartup();
  }

  private async loadHistoryOnStartup(): Promise<void> {
    try {
      await loadConversationHistory(this.context);
      this.historyLoaded = true;
      console.log('Conversation history loaded on startup');
    } catch (error) {
      console.error('Failed to load conversation history on startup:', error);
    }
  }
    
  resolveWebviewView(
    webviewView: vscode.WebviewView
  ): void {
    console.log('‚úÖ resolveWebviewView CALLED');
    webviewView.webview.options = {
      enableScripts: true,
      localResourceRoots: [vscode.Uri.joinPath(this.context.extensionUri, 'media')]
    };
    
    const scriptUri = webviewView.webview.asWebviewUri(
      vscode.Uri.joinPath(this.context.extensionUri, 'media', 'main.js')
    );
    const styleUri = webviewView.webview.asWebviewUri(
      vscode.Uri.joinPath(this.context.extensionUri, 'media', 'styles.css')
    );
    const logoUri = webviewView.webview.asWebviewUri(
      vscode.Uri.joinPath(this.context.extensionUri, 'resources', 'ai-icon.svg')
    );

    var htmlContent = this.getHtml(this.context.extensionUri);

    webviewView.webview.html = htmlContent
      .replace('{{scriptUri}}', scriptUri.path)
      .replace('{{styleUri}}', styleUri.path)
      .replace('{{logoUri}}', logoUri.path);

    // Webview ba≈ülatƒ±ldƒ±ƒüƒ±nda mevcut provider'ƒ± g√∂nder
    const currentProvider = getCurrentProvider();
    webviewView.webview.postMessage({ 
      command: 'currentProvider', 
      provider: currentProvider,
      displayName: getProviderDisplayName(currentProvider),
      availableProviders: getAvailableProviders().map(p => ({
        value: p,
        displayName: getProviderDisplayName(p)
      }))
    });


    
    webviewView.webview.onDidReceiveMessage(async message => {
      if (message.command === 'sendPrompt') {
        try {
          // Proje bilgilerini AI'ya g√∂nder
          let enhancedPrompt = message.text;
          let imageData: string | undefined;
          
          // Resim varsa i≈üle
          if (message.imageData) {
            try {
              const imagePath = await saveImageToProject(message.imageData, this.context);
              imageData = message.imageData;
              enhancedPrompt += `\n\nüì∑ **Y√ºklenen resim:** ${path.basename(imagePath)}`;
            } catch (error) {
              console.error('Resim kaydedilemedi:', error);
            }
          }
          
          // Eƒüer prompt dosya i≈ülemleri ile ilgiliyse, proje bilgilerini ekle
          if (message.text.toLowerCase().includes('dosya') || 
              message.text.toLowerCase().includes('file') ||
              message.text.toLowerCase().includes('proje') ||
              message.text.toLowerCase().includes('project') ||
              message.text.toLowerCase().includes('kod') ||
              message.text.toLowerCase().includes('code') ||
              message.text.toLowerCase().includes('yap') ||
              message.text.toLowerCase().includes('olu≈ütur') ||
              message.text.toLowerCase().includes('create') ||
              message.text.toLowerCase().includes('make') ||
              message.text.toLowerCase().includes('app') ||
              message.text.toLowerCase().includes('uygulama') ||
              message.text.toLowerCase().includes('revize') ||
              message.text.toLowerCase().includes('d√ºzenle') ||
              message.text.toLowerCase().includes('edit')) {
            
            const fileTree = await getFileTree();
 enhancedPrompt = `Proje yapƒ±sƒ±:
\`\`\`
${fileTree}
\`\`\`

Kullanƒ±cƒ± sorusu: ${message.text}

A≈üaƒüƒ±daki 4 i≈ülem t√ºr√ºnden istediƒüin kadarƒ±nƒ± kullanabilirsin. Her dosya i≈ülemi i√ßin ayrƒ± bir **kod bloƒüu** kullan:

---

### üí° Desteklenen ƒ∞≈ülem T√ºrleri

1. ‚úèÔ∏è Dosya G√ºncelleme  
\`\`\`update:dizin/dosya_adƒ±
(dosyanƒ±n yeni i√ßeriƒüi)
\`\`\`

2. üìÑ Yeni Dosya Olu≈üturma  
\`\`\`create:dizin/yeni_dosya_adƒ±
(yeni dosyanƒ±n i√ßeriƒüi)
\`\`\`

3. ‚ùå Dosya Silme  
\`\`\`delete:dizin/dosya_adƒ±
\`\`\`

4. üìñ Dosya Okuma ƒ∞steƒüi  
\`\`\`read:dizin/dosya_adƒ±
\`\`\`

---

## üìå Kurallar:

- ‚úÖ Cevap **birden fazla kod bloƒüu** i√ßerebilir. Her dosya i≈ülemi i√ßin ayrƒ± kod bloƒüu kullan.
- üßæ Her blok yukarƒ±daki 4 formatta biri ile ba≈ülamalƒ± (\`update:\`, \`create:\`, \`delete:\`, \`read:\`).
- ‚úÖ Kod bloƒüu dƒ±≈üƒ±nda a√ßƒ±klama yapabilirsin, ancak dosya i≈ülemleri i√ßin mutlaka kod bloƒüu kullan.
- ‚ö†Ô∏è Kod bloƒüu i√ßeriƒüi yalnƒ±zca i≈ülemle ilgili olmalƒ±.
- üß™ Dosya yollarƒ± tam ve ge√ßerli olmalƒ± (\`src/...\` gibi).
- üßπ Kod bloƒüu etiketleri ve i√ßeriƒüi arasƒ±nda bo≈üluk bƒ±rakma (√∂rnek: \`\`\`update:src/index.js\`).
- Sana bir resim dosyasƒ± veya bir url verildiyse onu detaylƒ±ca incele ve onun ile ilgili istenileni algƒ±layƒ±p yerine getir (√∂rnek: bir url verildi ve onu aynƒ±sƒ± yap dene bilir veya url verilir buradaki t√ºm bilgileri tara ve o kapsamda benim √ß√∂z√ºm√ºme cevap ver denebilir. ) bu kƒ±sƒ±m a≈üƒ±rƒ± kritik .
---

## üéØ √ñrnek ‚Äì √áoklu ƒ∞≈ülem Cevabƒ±:

\`\`\`update:src/App.js
import React from 'react';
function App() {
  return <div>Yeni i√ßerik</div>;
}
export default App;
\`\`\`

\`\`\`create:src/utils/math.js
export function sum(a, b) {
  return a + b;
}
\`\`\`

\`\`\`delete:src/old/DeprecatedComponent.jsx
\`\`\`

\`\`\`read:src/hooks/useAuth.js
\`\`\`
`;
          }
          
                      const response = await askAI(enhancedPrompt, message.text, imageData);
          
          console.log('AI Response:', response);
          console.log('Response length:', response.length);
          
          // AI yanƒ±tƒ±nƒ± i≈üle ve dosya i≈ülemlerini ger√ßekle≈ütir
          const processedResponse = await processAIResponse(response, webviewView);
          
          console.log('Processed Response:', processedResponse);
          console.log('Processed Response length:', processedResponse.length);
          const html = marked(processedResponse);
          webviewView.webview.postMessage({ command: 'addResponse', html: html });
          
          // Her mesajdan sonra history'yi kaydet
          await saveConversationHistory(this.context);
        } catch (error) {
          console.error('Error processing message:', error);
          const errorMessage = error instanceof Error ? error.message : 'Unknown error';
          webviewView.webview.postMessage({ 
            command: 'addResponse', 
            html: '<p style="color: red;">Error: ' + errorMessage + '</p>' 
          });
        }
      } else if (message.command === 'clearChat') {
        // Clear conversation history when chat is cleared
        clearConversationHistory();
        webviewView.webview.postMessage({ command: 'chatCleared' });
        
        // History dosyasƒ±nƒ± da sil
        try {
          const historyPath = getHistoryFilePath(this.context);
          if (fs.existsSync(historyPath)) {
            await fs.promises.unlink(historyPath);
          }
        } catch (error) {
          console.error('History dosyasƒ± silinemedi:', error);
        }
      } else if (message.command === 'getHistory') {
        // Send conversation history to webview
        const history = getConversationHistory();
        webviewView.webview.postMessage({ command: 'historyLoaded', history: history });
      } else if (message.command === 'readFile') {
        // Dosya okuma
        try {
          const content = await readFileContent(message.filePath);
          webviewView.webview.postMessage({ 
            command: 'fileContent', 
            filePath: message.filePath, 
            content: content 
          });
        } catch (error) {
          webviewView.webview.postMessage({ 
            command: 'fileError', 
            error: error instanceof Error ? error.message : 'Unknown error' 
          });
        }
      } else if (message.command === 'writeFile') {
        // Dosya yazma
        try {
          await writeFileContent(message.filePath, message.content);
          webviewView.webview.postMessage({ 
            command: 'fileWritten', 
            filePath: message.filePath 
          });
        } catch (error) {
          webviewView.webview.postMessage({ 
            command: 'fileError', 
            error: error instanceof Error ? error.message : 'Unknown error' 
          });
        }
      } else if (message.command === 'getFileTree') {
        // Dosya aƒüacƒ± alma
        try {
          const fileTree = await getFileTree();
          webviewView.webview.postMessage({ 
            command: 'fileTree', 
            tree: fileTree 
          });
        } catch (error) {
          webviewView.webview.postMessage({ 
            command: 'fileError', 
            error: error instanceof Error ? error.message : 'Unknown error' 
          });
        }
      } else if (message.command === 'getProjectFiles') {
        // Proje dosyalarƒ±nƒ± alma
        try {
          const files = await getProjectFiles();
          webviewView.webview.postMessage({ 
            command: 'projectFiles', 
            files: files 
          });
        } catch (error) {
          webviewView.webview.postMessage({ 
            command: 'fileError', 
            error: error instanceof Error ? error.message : 'Unknown error' 
          });
        }
      } else if (message.command === 'changeProvider') {
        // AI provider deƒüi≈ütirme - sadece provider'ƒ± deƒüi≈ütir, chat'i temizleme
        const newProvider = message.provider as AIProvider;
        setAIProvider(newProvider);
        
        // Webview'e provider bilgisini g√∂nder
        webviewView.webview.postMessage({ 
          command: 'providerChanged', 
          provider: newProvider,
          displayName: getProviderDisplayName(newProvider)
        });
      } else if (message.command === 'getCurrentProvider') {
        // Mevcut provider bilgisini g√∂nder
        const provider = getCurrentProvider();
        webviewView.webview.postMessage({ 
          command: 'currentProvider', 
          provider: provider,
          displayName: getProviderDisplayName(provider),
          availableProviders: getAvailableProviders().map(p => ({
            value: p,
            displayName: getProviderDisplayName(p)
          }))
        });
      }
    });
  }

  private getHtml(uri: vscode.Uri): string {
    const fs = require('fs');
    const path = require('path');
    const htmlPath = path.join(uri.path, 'src', 'webviewContent.html');
    return fs.readFileSync(htmlPath, 'utf8');
  }
}


